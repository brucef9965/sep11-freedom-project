<!DOCTYPE html>
<html>
    <head>
        <!-- Required meta tags -->
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet" />
        <link href="style.css" rel="stylesheet" type="text/css" />
        <style>
            /* CSS */

        </style>

        <title>Tinkering Tool</title>
    </head>
    <body>
        <!-- HTML -->
        <a-scene>

            <a-scene>
                <a-assets>
                  <img id="cynthia" src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQb8G96K6xsSxCk29KhDjA2b7hRhDJ7S5DCzg&s">
                </a-assets>
                <a-image src="#cynthia"></a-image>
              </a-scene>


        </a-scene>

        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
        <!-- <script src="script.js"></script> -->
        <script>
            // JS
            AFRAME.registerComponent('random-color', {
              dependecies: ['material'],

              init: function () {
                // Set material component's color property to a random color.
                this.el.setAttribute('material', 'color', getRandomColor())
             }
           });

           function getRandomColor() {
            const letters = '0123456789ABCDEF';
            var color = '#';
            for (var i = 0; i < 6; i++ ) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
           }

           document.querySelector('#blockHand').addEventListener(`click`, function (evt) {
            // Create a blank entity.
            var newVoxelEl = document.createElement('a-entity');

             // Use the mixin to make it a voxel.
            newVoxelEl.setAttribute('mixin', 'voxel');

            // Get normal of the face of intersection and scale it down a bit
            var normal = evt.detail.intersection.face.normal;
            normal.multiplyScalar(0.25);

            // Get the position of the intersection and add our scaled normal
            var position = evt.detail.intersection.point;
            position.add(normal);

            // Set the position using intersection point. The `snap` component above which
            // is part of the mixin will snap it to the closest half meter.
            newVoxelEl.setAttribute('position', position);

            // Add to the scene with `appendChild`.
            this.appendChild(newVoxelEl);
        });
        </script>
    </body>
</html>